use defuse_sandbox::extensions::defuse::{
    contract::contract::Role, intents::ExecuteIntentsExt, relayer::RelayerKeysExt,
};
use rstest::rstest;

use crate::{
    sandbox::{
        SigningAccount,
        api::{Signer, signer::generate_secret_key},
        extensions::acl::{AclExt, AclViewExt},
    },
    tests::defuse::env::Env,
    utils::asserts::ResultAssertsExt,
};

#[rstest]
#[tokio::test]
async fn relayer_keys() {
    let env = Env::builder().deployer_as_super_admin().build().await;
    let (user, other_user) = futures::join!(env.create_user(), env.create_user());

    env.acl_grant_role(env.defuse.id(), Role::RelayerKeysManager, user.id())
        .await
        .unwrap();

    // We generate a new key, because all keys generated by Near Workspaces are the same
    let new_relayer_signer_secret_key = generate_secret_key().unwrap();
    let new_relayer_public_key_near_sdk = new_relayer_signer_secret_key
        .public_key()
        .to_string()
        .parse()
        .unwrap();
    let new_relayer_signer = SigningAccount::new(
        env.defuse.clone(),
        Signer::from_secret_key(new_relayer_signer_secret_key).unwrap(),
    );

    // Attempt to use the key that we still didn't add, to execute an intent, which fails
    new_relayer_signer
        .simulate_and_execute_intents(env.defuse.id(), []) // Empty because it's just to ensure that authorization works/doesn't work
        .await
        .unwrap_err();

    // A random, unauthorized user attempts to add a key (no role `Role::RelayerKeysManager`) and fails
    other_user
        .add_relayer_key(env.defuse.id(), &new_relayer_public_key_near_sdk)
        .await
        .assert_err_contains("Requires one of these roles:");

    // A `Role::RelayerKeysManager` attempts to add the key, successfully
    user.add_relayer_key(env.defuse.id(), &new_relayer_public_key_near_sdk)
        .await
        .unwrap();

    // Attempt to add a key that already exists
    user.add_relayer_key(env.defuse.id(), &new_relayer_public_key_near_sdk)
        .await
        .assert_err_contains("key already exists");

    // Create a Function-call Key, then use it to execute an (empty) intent
    new_relayer_signer
        .simulate_and_execute_intents(env.defuse.id(), []) // Empty because it's just to ensure that authorization works/doesn't work
        .await
        .unwrap();

    // Attempt to delete the key by an unauthorized user
    other_user
        .delete_relayer_key(env.defuse.id(), &new_relayer_public_key_near_sdk)
        .await
        .assert_err_contains("Requires one of these roles:");

    // Delete the relayer key by the authorized entity
    user.delete_relayer_key(env.defuse.id(), &new_relayer_public_key_near_sdk)
        .await
        .unwrap();

    // Delete the same key again, which won't work

    user.delete_relayer_key(env.defuse.id(), &new_relayer_public_key_near_sdk)
        .await
        .assert_err_contains("key not found");

    let access_keys = env.defuse.view_access_keys().await.unwrap();
    dbg!(&access_keys);
    assert!(!access_keys.is_empty());
}
